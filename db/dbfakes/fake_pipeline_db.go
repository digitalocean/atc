// This file was generated by counterfeiter
package dbfakes

import (
	"sync"
	"time"

	"code.cloudfoundry.org/lager"
	"github.com/concourse/atc"
	"github.com/concourse/atc/db"
	"github.com/concourse/atc/db/algorithm"
	"github.com/concourse/atc/db/lock"
)

type FakePipelineDB struct {
	PipelineStub        func() db.SavedPipeline
	pipelineMutex       sync.RWMutex
	pipelineArgsForCall []struct{}
	pipelineReturns     struct {
		result1 db.SavedPipeline
	}
	pipelineReturnsOnCall map[int]struct {
		result1 db.SavedPipeline
	}
	GetPipelineNameStub        func() string
	getPipelineNameMutex       sync.RWMutex
	getPipelineNameArgsForCall []struct{}
	getPipelineNameReturns     struct {
		result1 string
	}
	getPipelineNameReturnsOnCall map[int]struct {
		result1 string
	}
	GetPipelineIDStub        func() int
	getPipelineIDMutex       sync.RWMutex
	getPipelineIDArgsForCall []struct{}
	getPipelineIDReturns     struct {
		result1 int
	}
	getPipelineIDReturnsOnCall map[int]struct {
		result1 int
	}
	ScopedNameStub        func(string) string
	scopedNameMutex       sync.RWMutex
	scopedNameArgsForCall []struct {
		arg1 string
	}
	scopedNameReturns struct {
		result1 string
	}
	scopedNameReturnsOnCall map[int]struct {
		result1 string
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct{}
	teamIDReturns     struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	ConfigStub        func() atc.Config
	configMutex       sync.RWMutex
	configArgsForCall []struct{}
	configReturns     struct {
		result1 atc.Config
	}
	configReturnsOnCall map[int]struct {
		result1 atc.Config
	}
	ConfigVersionStub        func() db.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct{}
	configVersionReturns     struct {
		result1 db.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 db.ConfigVersion
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct{}
	reloadReturns     struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct{}
	pauseReturns     struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct{}
	unpauseReturns     struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	IsPausedStub        func() (bool, error)
	isPausedMutex       sync.RWMutex
	isPausedArgsForCall []struct{}
	isPausedReturns     struct {
		result1 bool
		result2 error
	}
	isPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsPublicStub        func() bool
	isPublicMutex       sync.RWMutex
	isPublicArgsForCall []struct{}
	isPublicReturns     struct {
		result1 bool
	}
	isPublicReturnsOnCall map[int]struct {
		result1 bool
	}
	AcquireSchedulingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireSchedulingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	GetResourceStub        func(resourceName string) (db.SavedResource, bool, error)
	getResourceMutex       sync.RWMutex
	getResourceArgsForCall []struct {
		resourceName string
	}
	getResourceReturns struct {
		result1 db.SavedResource
		result2 bool
		result3 error
	}
	getResourceReturnsOnCall map[int]struct {
		result1 db.SavedResource
		result2 bool
		result3 error
	}
	GetResourceTypeStub        func(resourceTypeName string) (db.SavedResourceType, bool, error)
	getResourceTypeMutex       sync.RWMutex
	getResourceTypeArgsForCall []struct {
		resourceTypeName string
	}
	getResourceTypeReturns struct {
		result1 db.SavedResourceType
		result2 bool
		result3 error
	}
	getResourceTypeReturnsOnCall map[int]struct {
		result1 db.SavedResourceType
		result2 bool
		result3 error
	}
	SaveResourceTypeVersionStub        func(atc.ResourceType, atc.Version) error
	saveResourceTypeVersionMutex       sync.RWMutex
	saveResourceTypeVersionArgsForCall []struct {
		arg1 atc.ResourceType
		arg2 atc.Version
	}
	saveResourceTypeVersionReturns struct {
		result1 error
	}
	saveResourceTypeVersionReturnsOnCall map[int]struct {
		result1 error
	}
	EnableVersionedResourceStub        func(versionedResourceID int) error
	enableVersionedResourceMutex       sync.RWMutex
	enableVersionedResourceArgsForCall []struct {
		versionedResourceID int
	}
	enableVersionedResourceReturns struct {
		result1 error
	}
	enableVersionedResourceReturnsOnCall map[int]struct {
		result1 error
	}
	SetResourceCheckErrorStub        func(resource db.SavedResource, err error) error
	setResourceCheckErrorMutex       sync.RWMutex
	setResourceCheckErrorArgsForCall []struct {
		resource db.SavedResource
		err      error
	}
	setResourceCheckErrorReturns struct {
		result1 error
	}
	setResourceCheckErrorReturnsOnCall map[int]struct {
		result1 error
	}
	GetJobStub        func(job string) (db.SavedJob, bool, error)
	getJobMutex       sync.RWMutex
	getJobArgsForCall []struct {
		job string
	}
	getJobReturns struct {
		result1 db.SavedJob
		result2 bool
		result3 error
	}
	getJobReturnsOnCall map[int]struct {
		result1 db.SavedJob
		result2 bool
		result3 error
	}
	GetVersionedResourceByVersionStub        func(atcVersion atc.Version, resourceName string) (db.SavedVersionedResource, bool, error)
	getVersionedResourceByVersionMutex       sync.RWMutex
	getVersionedResourceByVersionArgsForCall []struct {
		atcVersion   atc.Version
		resourceName string
	}
	getVersionedResourceByVersionReturns struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	getVersionedResourceByVersionReturnsOnCall map[int]struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}
	SaveIndependentInputMappingStub        func(inputMapping algorithm.InputMapping, jobName string) error
	saveIndependentInputMappingMutex       sync.RWMutex
	saveIndependentInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}
	saveIndependentInputMappingReturns struct {
		result1 error
	}
	saveIndependentInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	SaveNextInputMappingStub        func(inputMapping algorithm.InputMapping, jobName string) error
	saveNextInputMappingMutex       sync.RWMutex
	saveNextInputMappingArgsForCall []struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}
	saveNextInputMappingReturns struct {
		result1 error
	}
	saveNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	PauseJobStub        func(job string) error
	pauseJobMutex       sync.RWMutex
	pauseJobArgsForCall []struct {
		job string
	}
	pauseJobReturns struct {
		result1 error
	}
	pauseJobReturnsOnCall map[int]struct {
		result1 error
	}
	UnpauseJobStub        func(job string) error
	unpauseJobMutex       sync.RWMutex
	unpauseJobArgsForCall []struct {
		job string
	}
	unpauseJobReturns struct {
		result1 error
	}
	unpauseJobReturnsOnCall map[int]struct {
		result1 error
	}
	GetNextBuildInputsStub        func(jobName string) ([]db.BuildInput, bool, error)
	getNextBuildInputsMutex       sync.RWMutex
	getNextBuildInputsArgsForCall []struct {
		jobName string
	}
	getNextBuildInputsReturns struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	getNextBuildInputsReturnsOnCall map[int]struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}
	DeleteNextInputMappingStub        func(jobName string) error
	deleteNextInputMappingMutex       sync.RWMutex
	deleteNextInputMappingArgsForCall []struct {
		jobName string
	}
	deleteNextInputMappingReturns struct {
		result1 error
	}
	deleteNextInputMappingReturnsOnCall map[int]struct {
		result1 error
	}
	GetRunningBuildsBySerialGroupStub        func(jobName string, serialGroups []string) ([]db.Build, error)
	getRunningBuildsBySerialGroupMutex       sync.RWMutex
	getRunningBuildsBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getRunningBuildsBySerialGroupReturns struct {
		result1 []db.Build
		result2 error
	}
	getRunningBuildsBySerialGroupReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetNextPendingBuildBySerialGroupStub        func(jobName string, serialGroups []string) (db.Build, bool, error)
	getNextPendingBuildBySerialGroupMutex       sync.RWMutex
	getNextPendingBuildBySerialGroupArgsForCall []struct {
		jobName      string
		serialGroups []string
	}
	getNextPendingBuildBySerialGroupReturns struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	getNextPendingBuildBySerialGroupReturnsOnCall map[int]struct {
		result1 db.Build
		result2 bool
		result3 error
	}
	GetJobFinishedAndNextBuildStub        func(job string) (db.Build, db.Build, error)
	getJobFinishedAndNextBuildMutex       sync.RWMutex
	getJobFinishedAndNextBuildArgsForCall []struct {
		job string
	}
	getJobFinishedAndNextBuildReturns struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}
	getJobFinishedAndNextBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}
	GetAllJobBuildsStub        func(job string) ([]db.Build, error)
	getAllJobBuildsMutex       sync.RWMutex
	getAllJobBuildsArgsForCall []struct {
		job string
	}
	getAllJobBuildsReturns struct {
		result1 []db.Build
		result2 error
	}
	getAllJobBuildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	CreateJobBuildStub        func(job string) (db.Build, error)
	createJobBuildMutex       sync.RWMutex
	createJobBuildArgsForCall []struct {
		job string
	}
	createJobBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createJobBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	SetMaxInFlightReachedStub        func(job string, reached bool) error
	setMaxInFlightReachedMutex       sync.RWMutex
	setMaxInFlightReachedArgsForCall []struct {
		job     string
		reached bool
	}
	setMaxInFlightReachedReturns struct {
		result1 error
	}
	setMaxInFlightReachedReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFirstLoggedBuildIDStub        func(job string, newFirstLoggedBuildID int) error
	updateFirstLoggedBuildIDMutex       sync.RWMutex
	updateFirstLoggedBuildIDArgsForCall []struct {
		job                   string
		newFirstLoggedBuildID int
	}
	updateFirstLoggedBuildIDReturns struct {
		result1 error
	}
	updateFirstLoggedBuildIDReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateBuildToScheduledStub        func(buildID int) (bool, error)
	updateBuildToScheduledMutex       sync.RWMutex
	updateBuildToScheduledArgsForCall []struct {
		buildID int
	}
	updateBuildToScheduledReturns struct {
		result1 bool
		result2 error
	}
	updateBuildToScheduledReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetBuildsWithVersionAsInputStub        func(versionedResourceID int) ([]db.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(versionedResourceID int) ([]db.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		versionedResourceID int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct{}
	exposeReturns     struct {
		result1 error
	}
	exposeReturnsOnCall map[int]struct {
		result1 error
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct{}
	hideReturns     struct {
		result1 error
	}
	hideReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipelineDB) Pipeline() db.SavedPipeline {
	fake.pipelineMutex.Lock()
	ret, specificReturn := fake.pipelineReturnsOnCall[len(fake.pipelineArgsForCall)]
	fake.pipelineArgsForCall = append(fake.pipelineArgsForCall, struct{}{})
	fake.recordInvocation("Pipeline", []interface{}{})
	fake.pipelineMutex.Unlock()
	if fake.PipelineStub != nil {
		return fake.PipelineStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pipelineReturns.result1
}

func (fake *FakePipelineDB) PipelineCallCount() int {
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	return len(fake.pipelineArgsForCall)
}

func (fake *FakePipelineDB) PipelineReturns(result1 db.SavedPipeline) {
	fake.PipelineStub = nil
	fake.pipelineReturns = struct {
		result1 db.SavedPipeline
	}{result1}
}

func (fake *FakePipelineDB) PipelineReturnsOnCall(i int, result1 db.SavedPipeline) {
	fake.PipelineStub = nil
	if fake.pipelineReturnsOnCall == nil {
		fake.pipelineReturnsOnCall = make(map[int]struct {
			result1 db.SavedPipeline
		})
	}
	fake.pipelineReturnsOnCall[i] = struct {
		result1 db.SavedPipeline
	}{result1}
}

func (fake *FakePipelineDB) GetPipelineName() string {
	fake.getPipelineNameMutex.Lock()
	ret, specificReturn := fake.getPipelineNameReturnsOnCall[len(fake.getPipelineNameArgsForCall)]
	fake.getPipelineNameArgsForCall = append(fake.getPipelineNameArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineName", []interface{}{})
	fake.getPipelineNameMutex.Unlock()
	if fake.GetPipelineNameStub != nil {
		return fake.GetPipelineNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPipelineNameReturns.result1
}

func (fake *FakePipelineDB) GetPipelineNameCallCount() int {
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	return len(fake.getPipelineNameArgsForCall)
}

func (fake *FakePipelineDB) GetPipelineNameReturns(result1 string) {
	fake.GetPipelineNameStub = nil
	fake.getPipelineNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipelineDB) GetPipelineNameReturnsOnCall(i int, result1 string) {
	fake.GetPipelineNameStub = nil
	if fake.getPipelineNameReturnsOnCall == nil {
		fake.getPipelineNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPipelineNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipelineDB) GetPipelineID() int {
	fake.getPipelineIDMutex.Lock()
	ret, specificReturn := fake.getPipelineIDReturnsOnCall[len(fake.getPipelineIDArgsForCall)]
	fake.getPipelineIDArgsForCall = append(fake.getPipelineIDArgsForCall, struct{}{})
	fake.recordInvocation("GetPipelineID", []interface{}{})
	fake.getPipelineIDMutex.Unlock()
	if fake.GetPipelineIDStub != nil {
		return fake.GetPipelineIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getPipelineIDReturns.result1
}

func (fake *FakePipelineDB) GetPipelineIDCallCount() int {
	fake.getPipelineIDMutex.RLock()
	defer fake.getPipelineIDMutex.RUnlock()
	return len(fake.getPipelineIDArgsForCall)
}

func (fake *FakePipelineDB) GetPipelineIDReturns(result1 int) {
	fake.GetPipelineIDStub = nil
	fake.getPipelineIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipelineDB) GetPipelineIDReturnsOnCall(i int, result1 int) {
	fake.GetPipelineIDStub = nil
	if fake.getPipelineIDReturnsOnCall == nil {
		fake.getPipelineIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getPipelineIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipelineDB) ScopedName(arg1 string) string {
	fake.scopedNameMutex.Lock()
	ret, specificReturn := fake.scopedNameReturnsOnCall[len(fake.scopedNameArgsForCall)]
	fake.scopedNameArgsForCall = append(fake.scopedNameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ScopedName", []interface{}{arg1})
	fake.scopedNameMutex.Unlock()
	if fake.ScopedNameStub != nil {
		return fake.ScopedNameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.scopedNameReturns.result1
}

func (fake *FakePipelineDB) ScopedNameCallCount() int {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return len(fake.scopedNameArgsForCall)
}

func (fake *FakePipelineDB) ScopedNameArgsForCall(i int) string {
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	return fake.scopedNameArgsForCall[i].arg1
}

func (fake *FakePipelineDB) ScopedNameReturns(result1 string) {
	fake.ScopedNameStub = nil
	fake.scopedNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipelineDB) ScopedNameReturnsOnCall(i int, result1 string) {
	fake.ScopedNameStub = nil
	if fake.scopedNameReturnsOnCall == nil {
		fake.scopedNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.scopedNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipelineDB) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct{}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.teamIDReturns.result1
}

func (fake *FakePipelineDB) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipelineDB) TeamIDReturns(result1 int) {
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipelineDB) TeamIDReturnsOnCall(i int, result1 int) {
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipelineDB) Config() atc.Config {
	fake.configMutex.Lock()
	ret, specificReturn := fake.configReturnsOnCall[len(fake.configArgsForCall)]
	fake.configArgsForCall = append(fake.configArgsForCall, struct{}{})
	fake.recordInvocation("Config", []interface{}{})
	fake.configMutex.Unlock()
	if fake.ConfigStub != nil {
		return fake.ConfigStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configReturns.result1
}

func (fake *FakePipelineDB) ConfigCallCount() int {
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	return len(fake.configArgsForCall)
}

func (fake *FakePipelineDB) ConfigReturns(result1 atc.Config) {
	fake.ConfigStub = nil
	fake.configReturns = struct {
		result1 atc.Config
	}{result1}
}

func (fake *FakePipelineDB) ConfigReturnsOnCall(i int, result1 atc.Config) {
	fake.ConfigStub = nil
	if fake.configReturnsOnCall == nil {
		fake.configReturnsOnCall = make(map[int]struct {
			result1 atc.Config
		})
	}
	fake.configReturnsOnCall[i] = struct {
		result1 atc.Config
	}{result1}
}

func (fake *FakePipelineDB) ConfigVersion() db.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct{}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.configVersionReturns.result1
}

func (fake *FakePipelineDB) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipelineDB) ConfigVersionReturns(result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipelineDB) ConfigVersionReturnsOnCall(i int, result1 db.ConfigVersion) {
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 db.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipelineDB) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct{}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.reloadReturns.result1, fake.reloadReturns.result2
}

func (fake *FakePipelineDB) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipelineDB) ReloadReturns(result1 bool, result2 error) {
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct{}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseReturns.result1
}

func (fake *FakePipelineDB) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipelineDB) PauseReturns(result1 error) {
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) PauseReturnsOnCall(i int, result1 error) {
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct{}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unpauseReturns.result1
}

func (fake *FakePipelineDB) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipelineDB) UnpauseReturns(result1 error) {
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UnpauseReturnsOnCall(i int, result1 error) {
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) IsPaused() (bool, error) {
	fake.isPausedMutex.Lock()
	ret, specificReturn := fake.isPausedReturnsOnCall[len(fake.isPausedArgsForCall)]
	fake.isPausedArgsForCall = append(fake.isPausedArgsForCall, struct{}{})
	fake.recordInvocation("IsPaused", []interface{}{})
	fake.isPausedMutex.Unlock()
	if fake.IsPausedStub != nil {
		return fake.IsPausedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.isPausedReturns.result1, fake.isPausedReturns.result2
}

func (fake *FakePipelineDB) IsPausedCallCount() int {
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	return len(fake.isPausedArgsForCall)
}

func (fake *FakePipelineDB) IsPausedReturns(result1 bool, result2 error) {
	fake.IsPausedStub = nil
	fake.isPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) IsPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.IsPausedStub = nil
	if fake.isPausedReturnsOnCall == nil {
		fake.isPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) IsPublic() bool {
	fake.isPublicMutex.Lock()
	ret, specificReturn := fake.isPublicReturnsOnCall[len(fake.isPublicArgsForCall)]
	fake.isPublicArgsForCall = append(fake.isPublicArgsForCall, struct{}{})
	fake.recordInvocation("IsPublic", []interface{}{})
	fake.isPublicMutex.Unlock()
	if fake.IsPublicStub != nil {
		return fake.IsPublicStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.isPublicReturns.result1
}

func (fake *FakePipelineDB) IsPublicCallCount() int {
	fake.isPublicMutex.RLock()
	defer fake.isPublicMutex.RUnlock()
	return len(fake.isPublicArgsForCall)
}

func (fake *FakePipelineDB) IsPublicReturns(result1 bool) {
	fake.IsPublicStub = nil
	fake.isPublicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipelineDB) IsPublicReturnsOnCall(i int, result1 bool) {
	fake.IsPublicStub = nil
	if fake.isPublicReturnsOnCall == nil {
		fake.isPublicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isPublicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipelineDB) AcquireSchedulingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	ret, specificReturn := fake.acquireSchedulingLockReturnsOnCall[len(fake.acquireSchedulingLockArgsForCall)]
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1, arg2})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.acquireSchedulingLockReturns.result1, fake.acquireSchedulingLockReturns.result2, fake.acquireSchedulingLockReturns.result3
}

func (fake *FakePipelineDB) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakePipelineDB) AcquireSchedulingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return fake.acquireSchedulingLockArgsForCall[i].arg1, fake.acquireSchedulingLockArgsForCall[i].arg2
}

func (fake *FakePipelineDB) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) AcquireSchedulingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.AcquireSchedulingLockStub = nil
	if fake.acquireSchedulingLockReturnsOnCall == nil {
		fake.acquireSchedulingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireSchedulingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResource(resourceName string) (db.SavedResource, bool, error) {
	fake.getResourceMutex.Lock()
	ret, specificReturn := fake.getResourceReturnsOnCall[len(fake.getResourceArgsForCall)]
	fake.getResourceArgsForCall = append(fake.getResourceArgsForCall, struct {
		resourceName string
	}{resourceName})
	fake.recordInvocation("GetResource", []interface{}{resourceName})
	fake.getResourceMutex.Unlock()
	if fake.GetResourceStub != nil {
		return fake.GetResourceStub(resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getResourceReturns.result1, fake.getResourceReturns.result2, fake.getResourceReturns.result3
}

func (fake *FakePipelineDB) GetResourceCallCount() int {
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	return len(fake.getResourceArgsForCall)
}

func (fake *FakePipelineDB) GetResourceArgsForCall(i int) string {
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	return fake.getResourceArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) GetResourceReturns(result1 db.SavedResource, result2 bool, result3 error) {
	fake.GetResourceStub = nil
	fake.getResourceReturns = struct {
		result1 db.SavedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResourceReturnsOnCall(i int, result1 db.SavedResource, result2 bool, result3 error) {
	fake.GetResourceStub = nil
	if fake.getResourceReturnsOnCall == nil {
		fake.getResourceReturnsOnCall = make(map[int]struct {
			result1 db.SavedResource
			result2 bool
			result3 error
		})
	}
	fake.getResourceReturnsOnCall[i] = struct {
		result1 db.SavedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResourceType(resourceTypeName string) (db.SavedResourceType, bool, error) {
	fake.getResourceTypeMutex.Lock()
	ret, specificReturn := fake.getResourceTypeReturnsOnCall[len(fake.getResourceTypeArgsForCall)]
	fake.getResourceTypeArgsForCall = append(fake.getResourceTypeArgsForCall, struct {
		resourceTypeName string
	}{resourceTypeName})
	fake.recordInvocation("GetResourceType", []interface{}{resourceTypeName})
	fake.getResourceTypeMutex.Unlock()
	if fake.GetResourceTypeStub != nil {
		return fake.GetResourceTypeStub(resourceTypeName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getResourceTypeReturns.result1, fake.getResourceTypeReturns.result2, fake.getResourceTypeReturns.result3
}

func (fake *FakePipelineDB) GetResourceTypeCallCount() int {
	fake.getResourceTypeMutex.RLock()
	defer fake.getResourceTypeMutex.RUnlock()
	return len(fake.getResourceTypeArgsForCall)
}

func (fake *FakePipelineDB) GetResourceTypeArgsForCall(i int) string {
	fake.getResourceTypeMutex.RLock()
	defer fake.getResourceTypeMutex.RUnlock()
	return fake.getResourceTypeArgsForCall[i].resourceTypeName
}

func (fake *FakePipelineDB) GetResourceTypeReturns(result1 db.SavedResourceType, result2 bool, result3 error) {
	fake.GetResourceTypeStub = nil
	fake.getResourceTypeReturns = struct {
		result1 db.SavedResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetResourceTypeReturnsOnCall(i int, result1 db.SavedResourceType, result2 bool, result3 error) {
	fake.GetResourceTypeStub = nil
	if fake.getResourceTypeReturnsOnCall == nil {
		fake.getResourceTypeReturnsOnCall = make(map[int]struct {
			result1 db.SavedResourceType
			result2 bool
			result3 error
		})
	}
	fake.getResourceTypeReturnsOnCall[i] = struct {
		result1 db.SavedResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) SaveResourceTypeVersion(arg1 atc.ResourceType, arg2 atc.Version) error {
	fake.saveResourceTypeVersionMutex.Lock()
	ret, specificReturn := fake.saveResourceTypeVersionReturnsOnCall[len(fake.saveResourceTypeVersionArgsForCall)]
	fake.saveResourceTypeVersionArgsForCall = append(fake.saveResourceTypeVersionArgsForCall, struct {
		arg1 atc.ResourceType
		arg2 atc.Version
	}{arg1, arg2})
	fake.recordInvocation("SaveResourceTypeVersion", []interface{}{arg1, arg2})
	fake.saveResourceTypeVersionMutex.Unlock()
	if fake.SaveResourceTypeVersionStub != nil {
		return fake.SaveResourceTypeVersionStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveResourceTypeVersionReturns.result1
}

func (fake *FakePipelineDB) SaveResourceTypeVersionCallCount() int {
	fake.saveResourceTypeVersionMutex.RLock()
	defer fake.saveResourceTypeVersionMutex.RUnlock()
	return len(fake.saveResourceTypeVersionArgsForCall)
}

func (fake *FakePipelineDB) SaveResourceTypeVersionArgsForCall(i int) (atc.ResourceType, atc.Version) {
	fake.saveResourceTypeVersionMutex.RLock()
	defer fake.saveResourceTypeVersionMutex.RUnlock()
	return fake.saveResourceTypeVersionArgsForCall[i].arg1, fake.saveResourceTypeVersionArgsForCall[i].arg2
}

func (fake *FakePipelineDB) SaveResourceTypeVersionReturns(result1 error) {
	fake.SaveResourceTypeVersionStub = nil
	fake.saveResourceTypeVersionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SaveResourceTypeVersionReturnsOnCall(i int, result1 error) {
	fake.SaveResourceTypeVersionStub = nil
	if fake.saveResourceTypeVersionReturnsOnCall == nil {
		fake.saveResourceTypeVersionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveResourceTypeVersionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) EnableVersionedResource(versionedResourceID int) error {
	fake.enableVersionedResourceMutex.Lock()
	ret, specificReturn := fake.enableVersionedResourceReturnsOnCall[len(fake.enableVersionedResourceArgsForCall)]
	fake.enableVersionedResourceArgsForCall = append(fake.enableVersionedResourceArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("EnableVersionedResource", []interface{}{versionedResourceID})
	fake.enableVersionedResourceMutex.Unlock()
	if fake.EnableVersionedResourceStub != nil {
		return fake.EnableVersionedResourceStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.enableVersionedResourceReturns.result1
}

func (fake *FakePipelineDB) EnableVersionedResourceCallCount() int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return len(fake.enableVersionedResourceArgsForCall)
}

func (fake *FakePipelineDB) EnableVersionedResourceArgsForCall(i int) int {
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	return fake.enableVersionedResourceArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) EnableVersionedResourceReturns(result1 error) {
	fake.EnableVersionedResourceStub = nil
	fake.enableVersionedResourceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) EnableVersionedResourceReturnsOnCall(i int, result1 error) {
	fake.EnableVersionedResourceStub = nil
	if fake.enableVersionedResourceReturnsOnCall == nil {
		fake.enableVersionedResourceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.enableVersionedResourceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SetResourceCheckError(resource db.SavedResource, err error) error {
	fake.setResourceCheckErrorMutex.Lock()
	ret, specificReturn := fake.setResourceCheckErrorReturnsOnCall[len(fake.setResourceCheckErrorArgsForCall)]
	fake.setResourceCheckErrorArgsForCall = append(fake.setResourceCheckErrorArgsForCall, struct {
		resource db.SavedResource
		err      error
	}{resource, err})
	fake.recordInvocation("SetResourceCheckError", []interface{}{resource, err})
	fake.setResourceCheckErrorMutex.Unlock()
	if fake.SetResourceCheckErrorStub != nil {
		return fake.SetResourceCheckErrorStub(resource, err)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setResourceCheckErrorReturns.result1
}

func (fake *FakePipelineDB) SetResourceCheckErrorCallCount() int {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return len(fake.setResourceCheckErrorArgsForCall)
}

func (fake *FakePipelineDB) SetResourceCheckErrorArgsForCall(i int) (db.SavedResource, error) {
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	return fake.setResourceCheckErrorArgsForCall[i].resource, fake.setResourceCheckErrorArgsForCall[i].err
}

func (fake *FakePipelineDB) SetResourceCheckErrorReturns(result1 error) {
	fake.SetResourceCheckErrorStub = nil
	fake.setResourceCheckErrorReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SetResourceCheckErrorReturnsOnCall(i int, result1 error) {
	fake.SetResourceCheckErrorStub = nil
	if fake.setResourceCheckErrorReturnsOnCall == nil {
		fake.setResourceCheckErrorReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setResourceCheckErrorReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetJob(job string) (db.SavedJob, bool, error) {
	fake.getJobMutex.Lock()
	ret, specificReturn := fake.getJobReturnsOnCall[len(fake.getJobArgsForCall)]
	fake.getJobArgsForCall = append(fake.getJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJob", []interface{}{job})
	fake.getJobMutex.Unlock()
	if fake.GetJobStub != nil {
		return fake.GetJobStub(job)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getJobReturns.result1, fake.getJobReturns.result2, fake.getJobReturns.result3
}

func (fake *FakePipelineDB) GetJobCallCount() int {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return len(fake.getJobArgsForCall)
}

func (fake *FakePipelineDB) GetJobArgsForCall(i int) string {
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	return fake.getJobArgsForCall[i].job
}

func (fake *FakePipelineDB) GetJobReturns(result1 db.SavedJob, result2 bool, result3 error) {
	fake.GetJobStub = nil
	fake.getJobReturns = struct {
		result1 db.SavedJob
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetJobReturnsOnCall(i int, result1 db.SavedJob, result2 bool, result3 error) {
	fake.GetJobStub = nil
	if fake.getJobReturnsOnCall == nil {
		fake.getJobReturnsOnCall = make(map[int]struct {
			result1 db.SavedJob
			result2 bool
			result3 error
		})
	}
	fake.getJobReturnsOnCall[i] = struct {
		result1 db.SavedJob
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetVersionedResourceByVersion(atcVersion atc.Version, resourceName string) (db.SavedVersionedResource, bool, error) {
	fake.getVersionedResourceByVersionMutex.Lock()
	ret, specificReturn := fake.getVersionedResourceByVersionReturnsOnCall[len(fake.getVersionedResourceByVersionArgsForCall)]
	fake.getVersionedResourceByVersionArgsForCall = append(fake.getVersionedResourceByVersionArgsForCall, struct {
		atcVersion   atc.Version
		resourceName string
	}{atcVersion, resourceName})
	fake.recordInvocation("GetVersionedResourceByVersion", []interface{}{atcVersion, resourceName})
	fake.getVersionedResourceByVersionMutex.Unlock()
	if fake.GetVersionedResourceByVersionStub != nil {
		return fake.GetVersionedResourceByVersionStub(atcVersion, resourceName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getVersionedResourceByVersionReturns.result1, fake.getVersionedResourceByVersionReturns.result2, fake.getVersionedResourceByVersionReturns.result3
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionCallCount() int {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return len(fake.getVersionedResourceByVersionArgsForCall)
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionArgsForCall(i int) (atc.Version, string) {
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	return fake.getVersionedResourceByVersionArgsForCall[i].atcVersion, fake.getVersionedResourceByVersionArgsForCall[i].resourceName
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionReturns(result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	fake.getVersionedResourceByVersionReturns = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetVersionedResourceByVersionReturnsOnCall(i int, result1 db.SavedVersionedResource, result2 bool, result3 error) {
	fake.GetVersionedResourceByVersionStub = nil
	if fake.getVersionedResourceByVersionReturnsOnCall == nil {
		fake.getVersionedResourceByVersionReturnsOnCall = make(map[int]struct {
			result1 db.SavedVersionedResource
			result2 bool
			result3 error
		})
	}
	fake.getVersionedResourceByVersionReturnsOnCall[i] = struct {
		result1 db.SavedVersionedResource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) SaveIndependentInputMapping(inputMapping algorithm.InputMapping, jobName string) error {
	fake.saveIndependentInputMappingMutex.Lock()
	ret, specificReturn := fake.saveIndependentInputMappingReturnsOnCall[len(fake.saveIndependentInputMappingArgsForCall)]
	fake.saveIndependentInputMappingArgsForCall = append(fake.saveIndependentInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}{inputMapping, jobName})
	fake.recordInvocation("SaveIndependentInputMapping", []interface{}{inputMapping, jobName})
	fake.saveIndependentInputMappingMutex.Unlock()
	if fake.SaveIndependentInputMappingStub != nil {
		return fake.SaveIndependentInputMappingStub(inputMapping, jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveIndependentInputMappingReturns.result1
}

func (fake *FakePipelineDB) SaveIndependentInputMappingCallCount() int {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return len(fake.saveIndependentInputMappingArgsForCall)
}

func (fake *FakePipelineDB) SaveIndependentInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	return fake.saveIndependentInputMappingArgsForCall[i].inputMapping, fake.saveIndependentInputMappingArgsForCall[i].jobName
}

func (fake *FakePipelineDB) SaveIndependentInputMappingReturns(result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	fake.saveIndependentInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SaveIndependentInputMappingReturnsOnCall(i int, result1 error) {
	fake.SaveIndependentInputMappingStub = nil
	if fake.saveIndependentInputMappingReturnsOnCall == nil {
		fake.saveIndependentInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveIndependentInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SaveNextInputMapping(inputMapping algorithm.InputMapping, jobName string) error {
	fake.saveNextInputMappingMutex.Lock()
	ret, specificReturn := fake.saveNextInputMappingReturnsOnCall[len(fake.saveNextInputMappingArgsForCall)]
	fake.saveNextInputMappingArgsForCall = append(fake.saveNextInputMappingArgsForCall, struct {
		inputMapping algorithm.InputMapping
		jobName      string
	}{inputMapping, jobName})
	fake.recordInvocation("SaveNextInputMapping", []interface{}{inputMapping, jobName})
	fake.saveNextInputMappingMutex.Unlock()
	if fake.SaveNextInputMappingStub != nil {
		return fake.SaveNextInputMappingStub(inputMapping, jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.saveNextInputMappingReturns.result1
}

func (fake *FakePipelineDB) SaveNextInputMappingCallCount() int {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return len(fake.saveNextInputMappingArgsForCall)
}

func (fake *FakePipelineDB) SaveNextInputMappingArgsForCall(i int) (algorithm.InputMapping, string) {
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	return fake.saveNextInputMappingArgsForCall[i].inputMapping, fake.saveNextInputMappingArgsForCall[i].jobName
}

func (fake *FakePipelineDB) SaveNextInputMappingReturns(result1 error) {
	fake.SaveNextInputMappingStub = nil
	fake.saveNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SaveNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.SaveNextInputMappingStub = nil
	if fake.saveNextInputMappingReturnsOnCall == nil {
		fake.saveNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) PauseJob(job string) error {
	fake.pauseJobMutex.Lock()
	ret, specificReturn := fake.pauseJobReturnsOnCall[len(fake.pauseJobArgsForCall)]
	fake.pauseJobArgsForCall = append(fake.pauseJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("PauseJob", []interface{}{job})
	fake.pauseJobMutex.Unlock()
	if fake.PauseJobStub != nil {
		return fake.PauseJobStub(job)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.pauseJobReturns.result1
}

func (fake *FakePipelineDB) PauseJobCallCount() int {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return len(fake.pauseJobArgsForCall)
}

func (fake *FakePipelineDB) PauseJobArgsForCall(i int) string {
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	return fake.pauseJobArgsForCall[i].job
}

func (fake *FakePipelineDB) PauseJobReturns(result1 error) {
	fake.PauseJobStub = nil
	fake.pauseJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) PauseJobReturnsOnCall(i int, result1 error) {
	fake.PauseJobStub = nil
	if fake.pauseJobReturnsOnCall == nil {
		fake.pauseJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UnpauseJob(job string) error {
	fake.unpauseJobMutex.Lock()
	ret, specificReturn := fake.unpauseJobReturnsOnCall[len(fake.unpauseJobArgsForCall)]
	fake.unpauseJobArgsForCall = append(fake.unpauseJobArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("UnpauseJob", []interface{}{job})
	fake.unpauseJobMutex.Unlock()
	if fake.UnpauseJobStub != nil {
		return fake.UnpauseJobStub(job)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.unpauseJobReturns.result1
}

func (fake *FakePipelineDB) UnpauseJobCallCount() int {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return len(fake.unpauseJobArgsForCall)
}

func (fake *FakePipelineDB) UnpauseJobArgsForCall(i int) string {
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	return fake.unpauseJobArgsForCall[i].job
}

func (fake *FakePipelineDB) UnpauseJobReturns(result1 error) {
	fake.UnpauseJobStub = nil
	fake.unpauseJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UnpauseJobReturnsOnCall(i int, result1 error) {
	fake.UnpauseJobStub = nil
	if fake.unpauseJobReturnsOnCall == nil {
		fake.unpauseJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetNextBuildInputs(jobName string) ([]db.BuildInput, bool, error) {
	fake.getNextBuildInputsMutex.Lock()
	ret, specificReturn := fake.getNextBuildInputsReturnsOnCall[len(fake.getNextBuildInputsArgsForCall)]
	fake.getNextBuildInputsArgsForCall = append(fake.getNextBuildInputsArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("GetNextBuildInputs", []interface{}{jobName})
	fake.getNextBuildInputsMutex.Unlock()
	if fake.GetNextBuildInputsStub != nil {
		return fake.GetNextBuildInputsStub(jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNextBuildInputsReturns.result1, fake.getNextBuildInputsReturns.result2, fake.getNextBuildInputsReturns.result3
}

func (fake *FakePipelineDB) GetNextBuildInputsCallCount() int {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return len(fake.getNextBuildInputsArgsForCall)
}

func (fake *FakePipelineDB) GetNextBuildInputsArgsForCall(i int) string {
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	return fake.getNextBuildInputsArgsForCall[i].jobName
}

func (fake *FakePipelineDB) GetNextBuildInputsReturns(result1 []db.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	fake.getNextBuildInputsReturns = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetNextBuildInputsReturnsOnCall(i int, result1 []db.BuildInput, result2 bool, result3 error) {
	fake.GetNextBuildInputsStub = nil
	if fake.getNextBuildInputsReturnsOnCall == nil {
		fake.getNextBuildInputsReturnsOnCall = make(map[int]struct {
			result1 []db.BuildInput
			result2 bool
			result3 error
		})
	}
	fake.getNextBuildInputsReturnsOnCall[i] = struct {
		result1 []db.BuildInput
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) DeleteNextInputMapping(jobName string) error {
	fake.deleteNextInputMappingMutex.Lock()
	ret, specificReturn := fake.deleteNextInputMappingReturnsOnCall[len(fake.deleteNextInputMappingArgsForCall)]
	fake.deleteNextInputMappingArgsForCall = append(fake.deleteNextInputMappingArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("DeleteNextInputMapping", []interface{}{jobName})
	fake.deleteNextInputMappingMutex.Unlock()
	if fake.DeleteNextInputMappingStub != nil {
		return fake.DeleteNextInputMappingStub(jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteNextInputMappingReturns.result1
}

func (fake *FakePipelineDB) DeleteNextInputMappingCallCount() int {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return len(fake.deleteNextInputMappingArgsForCall)
}

func (fake *FakePipelineDB) DeleteNextInputMappingArgsForCall(i int) string {
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	return fake.deleteNextInputMappingArgsForCall[i].jobName
}

func (fake *FakePipelineDB) DeleteNextInputMappingReturns(result1 error) {
	fake.DeleteNextInputMappingStub = nil
	fake.deleteNextInputMappingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) DeleteNextInputMappingReturnsOnCall(i int, result1 error) {
	fake.DeleteNextInputMappingStub = nil
	if fake.deleteNextInputMappingReturnsOnCall == nil {
		fake.deleteNextInputMappingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteNextInputMappingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroup(jobName string, serialGroups []string) ([]db.Build, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getRunningBuildsBySerialGroupMutex.Lock()
	ret, specificReturn := fake.getRunningBuildsBySerialGroupReturnsOnCall[len(fake.getRunningBuildsBySerialGroupArgsForCall)]
	fake.getRunningBuildsBySerialGroupArgsForCall = append(fake.getRunningBuildsBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetRunningBuildsBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getRunningBuildsBySerialGroupMutex.Unlock()
	if fake.GetRunningBuildsBySerialGroupStub != nil {
		return fake.GetRunningBuildsBySerialGroupStub(jobName, serialGroups)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getRunningBuildsBySerialGroupReturns.result1, fake.getRunningBuildsBySerialGroupReturns.result2
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupCallCount() int {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return len(fake.getRunningBuildsBySerialGroupArgsForCall)
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	return fake.getRunningBuildsBySerialGroupArgsForCall[i].jobName, fake.getRunningBuildsBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupReturns(result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	fake.getRunningBuildsBySerialGroupReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetRunningBuildsBySerialGroupReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetRunningBuildsBySerialGroupStub = nil
	if fake.getRunningBuildsBySerialGroupReturnsOnCall == nil {
		fake.getRunningBuildsBySerialGroupReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getRunningBuildsBySerialGroupReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroup(jobName string, serialGroups []string) (db.Build, bool, error) {
	var serialGroupsCopy []string
	if serialGroups != nil {
		serialGroupsCopy = make([]string, len(serialGroups))
		copy(serialGroupsCopy, serialGroups)
	}
	fake.getNextPendingBuildBySerialGroupMutex.Lock()
	ret, specificReturn := fake.getNextPendingBuildBySerialGroupReturnsOnCall[len(fake.getNextPendingBuildBySerialGroupArgsForCall)]
	fake.getNextPendingBuildBySerialGroupArgsForCall = append(fake.getNextPendingBuildBySerialGroupArgsForCall, struct {
		jobName      string
		serialGroups []string
	}{jobName, serialGroupsCopy})
	fake.recordInvocation("GetNextPendingBuildBySerialGroup", []interface{}{jobName, serialGroupsCopy})
	fake.getNextPendingBuildBySerialGroupMutex.Unlock()
	if fake.GetNextPendingBuildBySerialGroupStub != nil {
		return fake.GetNextPendingBuildBySerialGroupStub(jobName, serialGroups)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getNextPendingBuildBySerialGroupReturns.result1, fake.getNextPendingBuildBySerialGroupReturns.result2, fake.getNextPendingBuildBySerialGroupReturns.result3
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupCallCount() int {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return len(fake.getNextPendingBuildBySerialGroupArgsForCall)
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupArgsForCall(i int) (string, []string) {
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	return fake.getNextPendingBuildBySerialGroupArgsForCall[i].jobName, fake.getNextPendingBuildBySerialGroupArgsForCall[i].serialGroups
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupReturns(result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	fake.getNextPendingBuildBySerialGroupReturns = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetNextPendingBuildBySerialGroupReturnsOnCall(i int, result1 db.Build, result2 bool, result3 error) {
	fake.GetNextPendingBuildBySerialGroupStub = nil
	if fake.getNextPendingBuildBySerialGroupReturnsOnCall == nil {
		fake.getNextPendingBuildBySerialGroupReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 bool
			result3 error
		})
	}
	fake.getNextPendingBuildBySerialGroupReturnsOnCall[i] = struct {
		result1 db.Build
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuild(job string) (db.Build, db.Build, error) {
	fake.getJobFinishedAndNextBuildMutex.Lock()
	ret, specificReturn := fake.getJobFinishedAndNextBuildReturnsOnCall[len(fake.getJobFinishedAndNextBuildArgsForCall)]
	fake.getJobFinishedAndNextBuildArgsForCall = append(fake.getJobFinishedAndNextBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetJobFinishedAndNextBuild", []interface{}{job})
	fake.getJobFinishedAndNextBuildMutex.Unlock()
	if fake.GetJobFinishedAndNextBuildStub != nil {
		return fake.GetJobFinishedAndNextBuildStub(job)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.getJobFinishedAndNextBuildReturns.result1, fake.getJobFinishedAndNextBuildReturns.result2, fake.getJobFinishedAndNextBuildReturns.result3
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildCallCount() int {
	fake.getJobFinishedAndNextBuildMutex.RLock()
	defer fake.getJobFinishedAndNextBuildMutex.RUnlock()
	return len(fake.getJobFinishedAndNextBuildArgsForCall)
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildArgsForCall(i int) string {
	fake.getJobFinishedAndNextBuildMutex.RLock()
	defer fake.getJobFinishedAndNextBuildMutex.RUnlock()
	return fake.getJobFinishedAndNextBuildArgsForCall[i].job
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildReturns(result1 db.Build, result2 db.Build, result3 error) {
	fake.GetJobFinishedAndNextBuildStub = nil
	fake.getJobFinishedAndNextBuildReturns = struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetJobFinishedAndNextBuildReturnsOnCall(i int, result1 db.Build, result2 db.Build, result3 error) {
	fake.GetJobFinishedAndNextBuildStub = nil
	if fake.getJobFinishedAndNextBuildReturnsOnCall == nil {
		fake.getJobFinishedAndNextBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 db.Build
			result3 error
		})
	}
	fake.getJobFinishedAndNextBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 db.Build
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipelineDB) GetAllJobBuilds(job string) ([]db.Build, error) {
	fake.getAllJobBuildsMutex.Lock()
	ret, specificReturn := fake.getAllJobBuildsReturnsOnCall[len(fake.getAllJobBuildsArgsForCall)]
	fake.getAllJobBuildsArgsForCall = append(fake.getAllJobBuildsArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("GetAllJobBuilds", []interface{}{job})
	fake.getAllJobBuildsMutex.Unlock()
	if fake.GetAllJobBuildsStub != nil {
		return fake.GetAllJobBuildsStub(job)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAllJobBuildsReturns.result1, fake.getAllJobBuildsReturns.result2
}

func (fake *FakePipelineDB) GetAllJobBuildsCallCount() int {
	fake.getAllJobBuildsMutex.RLock()
	defer fake.getAllJobBuildsMutex.RUnlock()
	return len(fake.getAllJobBuildsArgsForCall)
}

func (fake *FakePipelineDB) GetAllJobBuildsArgsForCall(i int) string {
	fake.getAllJobBuildsMutex.RLock()
	defer fake.getAllJobBuildsMutex.RUnlock()
	return fake.getAllJobBuildsArgsForCall[i].job
}

func (fake *FakePipelineDB) GetAllJobBuildsReturns(result1 []db.Build, result2 error) {
	fake.GetAllJobBuildsStub = nil
	fake.getAllJobBuildsReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetAllJobBuildsReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetAllJobBuildsStub = nil
	if fake.getAllJobBuildsReturnsOnCall == nil {
		fake.getAllJobBuildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getAllJobBuildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) CreateJobBuild(job string) (db.Build, error) {
	fake.createJobBuildMutex.Lock()
	ret, specificReturn := fake.createJobBuildReturnsOnCall[len(fake.createJobBuildArgsForCall)]
	fake.createJobBuildArgsForCall = append(fake.createJobBuildArgsForCall, struct {
		job string
	}{job})
	fake.recordInvocation("CreateJobBuild", []interface{}{job})
	fake.createJobBuildMutex.Unlock()
	if fake.CreateJobBuildStub != nil {
		return fake.CreateJobBuildStub(job)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createJobBuildReturns.result1, fake.createJobBuildReturns.result2
}

func (fake *FakePipelineDB) CreateJobBuildCallCount() int {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return len(fake.createJobBuildArgsForCall)
}

func (fake *FakePipelineDB) CreateJobBuildArgsForCall(i int) string {
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	return fake.createJobBuildArgsForCall[i].job
}

func (fake *FakePipelineDB) CreateJobBuildReturns(result1 db.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	fake.createJobBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) CreateJobBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.CreateJobBuildStub = nil
	if fake.createJobBuildReturnsOnCall == nil {
		fake.createJobBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createJobBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) SetMaxInFlightReached(job string, reached bool) error {
	fake.setMaxInFlightReachedMutex.Lock()
	ret, specificReturn := fake.setMaxInFlightReachedReturnsOnCall[len(fake.setMaxInFlightReachedArgsForCall)]
	fake.setMaxInFlightReachedArgsForCall = append(fake.setMaxInFlightReachedArgsForCall, struct {
		job     string
		reached bool
	}{job, reached})
	fake.recordInvocation("SetMaxInFlightReached", []interface{}{job, reached})
	fake.setMaxInFlightReachedMutex.Unlock()
	if fake.SetMaxInFlightReachedStub != nil {
		return fake.SetMaxInFlightReachedStub(job, reached)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setMaxInFlightReachedReturns.result1
}

func (fake *FakePipelineDB) SetMaxInFlightReachedCallCount() int {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return len(fake.setMaxInFlightReachedArgsForCall)
}

func (fake *FakePipelineDB) SetMaxInFlightReachedArgsForCall(i int) (string, bool) {
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	return fake.setMaxInFlightReachedArgsForCall[i].job, fake.setMaxInFlightReachedArgsForCall[i].reached
}

func (fake *FakePipelineDB) SetMaxInFlightReachedReturns(result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	fake.setMaxInFlightReachedReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) SetMaxInFlightReachedReturnsOnCall(i int, result1 error) {
	fake.SetMaxInFlightReachedStub = nil
	if fake.setMaxInFlightReachedReturnsOnCall == nil {
		fake.setMaxInFlightReachedReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMaxInFlightReachedReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildID(job string, newFirstLoggedBuildID int) error {
	fake.updateFirstLoggedBuildIDMutex.Lock()
	ret, specificReturn := fake.updateFirstLoggedBuildIDReturnsOnCall[len(fake.updateFirstLoggedBuildIDArgsForCall)]
	fake.updateFirstLoggedBuildIDArgsForCall = append(fake.updateFirstLoggedBuildIDArgsForCall, struct {
		job                   string
		newFirstLoggedBuildID int
	}{job, newFirstLoggedBuildID})
	fake.recordInvocation("UpdateFirstLoggedBuildID", []interface{}{job, newFirstLoggedBuildID})
	fake.updateFirstLoggedBuildIDMutex.Unlock()
	if fake.UpdateFirstLoggedBuildIDStub != nil {
		return fake.UpdateFirstLoggedBuildIDStub(job, newFirstLoggedBuildID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateFirstLoggedBuildIDReturns.result1
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDCallCount() int {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return len(fake.updateFirstLoggedBuildIDArgsForCall)
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDArgsForCall(i int) (string, int) {
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	return fake.updateFirstLoggedBuildIDArgsForCall[i].job, fake.updateFirstLoggedBuildIDArgsForCall[i].newFirstLoggedBuildID
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDReturns(result1 error) {
	fake.UpdateFirstLoggedBuildIDStub = nil
	fake.updateFirstLoggedBuildIDReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UpdateFirstLoggedBuildIDReturnsOnCall(i int, result1 error) {
	fake.UpdateFirstLoggedBuildIDStub = nil
	if fake.updateFirstLoggedBuildIDReturnsOnCall == nil {
		fake.updateFirstLoggedBuildIDReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateFirstLoggedBuildIDReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) UpdateBuildToScheduled(buildID int) (bool, error) {
	fake.updateBuildToScheduledMutex.Lock()
	ret, specificReturn := fake.updateBuildToScheduledReturnsOnCall[len(fake.updateBuildToScheduledArgsForCall)]
	fake.updateBuildToScheduledArgsForCall = append(fake.updateBuildToScheduledArgsForCall, struct {
		buildID int
	}{buildID})
	fake.recordInvocation("UpdateBuildToScheduled", []interface{}{buildID})
	fake.updateBuildToScheduledMutex.Unlock()
	if fake.UpdateBuildToScheduledStub != nil {
		return fake.UpdateBuildToScheduledStub(buildID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.updateBuildToScheduledReturns.result1, fake.updateBuildToScheduledReturns.result2
}

func (fake *FakePipelineDB) UpdateBuildToScheduledCallCount() int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return len(fake.updateBuildToScheduledArgsForCall)
}

func (fake *FakePipelineDB) UpdateBuildToScheduledArgsForCall(i int) int {
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	return fake.updateBuildToScheduledArgsForCall[i].buildID
}

func (fake *FakePipelineDB) UpdateBuildToScheduledReturns(result1 bool, result2 error) {
	fake.UpdateBuildToScheduledStub = nil
	fake.updateBuildToScheduledReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) UpdateBuildToScheduledReturnsOnCall(i int, result1 bool, result2 error) {
	fake.UpdateBuildToScheduledStub = nil
	if fake.updateBuildToScheduledReturnsOnCall == nil {
		fake.updateBuildToScheduledReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateBuildToScheduledReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInput(versionedResourceID int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsInputReturnsOnCall[len(fake.getBuildsWithVersionAsInputArgsForCall)]
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if fake.GetBuildsWithVersionAsInputStub != nil {
		return fake.GetBuildsWithVersionAsInputStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsWithVersionAsInputReturns.result1, fake.getBuildsWithVersionAsInputReturns.result2
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return fake.getBuildsWithVersionAsInputArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsInputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsInputStub = nil
	if fake.getBuildsWithVersionAsInputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutput(versionedResourceID int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsOutputReturnsOnCall[len(fake.getBuildsWithVersionAsOutputArgsForCall)]
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		versionedResourceID int
	}{versionedResourceID})
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{versionedResourceID})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if fake.GetBuildsWithVersionAsOutputStub != nil {
		return fake.GetBuildsWithVersionAsOutputStub(versionedResourceID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getBuildsWithVersionAsOutputReturns.result1, fake.getBuildsWithVersionAsOutputReturns.result2
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputArgsForCall(i int) int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return fake.getBuildsWithVersionAsOutputArgsForCall[i].versionedResourceID
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputReturns(result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) GetBuildsWithVersionAsOutputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.GetBuildsWithVersionAsOutputStub = nil
	if fake.getBuildsWithVersionAsOutputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipelineDB) Expose() error {
	fake.exposeMutex.Lock()
	ret, specificReturn := fake.exposeReturnsOnCall[len(fake.exposeArgsForCall)]
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct{}{})
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if fake.ExposeStub != nil {
		return fake.ExposeStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.exposeReturns.result1
}

func (fake *FakePipelineDB) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipelineDB) ExposeReturns(result1 error) {
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) ExposeReturnsOnCall(i int, result1 error) {
	fake.ExposeStub = nil
	if fake.exposeReturnsOnCall == nil {
		fake.exposeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exposeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Hide() error {
	fake.hideMutex.Lock()
	ret, specificReturn := fake.hideReturnsOnCall[len(fake.hideArgsForCall)]
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct{}{})
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if fake.HideStub != nil {
		return fake.HideStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.hideReturns.result1
}

func (fake *FakePipelineDB) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipelineDB) HideReturns(result1 error) {
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) HideReturnsOnCall(i int, result1 error) {
	fake.HideStub = nil
	if fake.hideReturnsOnCall == nil {
		fake.hideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipelineDB) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.pipelineMutex.RLock()
	defer fake.pipelineMutex.RUnlock()
	fake.getPipelineNameMutex.RLock()
	defer fake.getPipelineNameMutex.RUnlock()
	fake.getPipelineIDMutex.RLock()
	defer fake.getPipelineIDMutex.RUnlock()
	fake.scopedNameMutex.RLock()
	defer fake.scopedNameMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.configMutex.RLock()
	defer fake.configMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	fake.isPausedMutex.RLock()
	defer fake.isPausedMutex.RUnlock()
	fake.isPublicMutex.RLock()
	defer fake.isPublicMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.getResourceMutex.RLock()
	defer fake.getResourceMutex.RUnlock()
	fake.getResourceTypeMutex.RLock()
	defer fake.getResourceTypeMutex.RUnlock()
	fake.saveResourceTypeVersionMutex.RLock()
	defer fake.saveResourceTypeVersionMutex.RUnlock()
	fake.enableVersionedResourceMutex.RLock()
	defer fake.enableVersionedResourceMutex.RUnlock()
	fake.setResourceCheckErrorMutex.RLock()
	defer fake.setResourceCheckErrorMutex.RUnlock()
	fake.getJobMutex.RLock()
	defer fake.getJobMutex.RUnlock()
	fake.getVersionedResourceByVersionMutex.RLock()
	defer fake.getVersionedResourceByVersionMutex.RUnlock()
	fake.saveIndependentInputMappingMutex.RLock()
	defer fake.saveIndependentInputMappingMutex.RUnlock()
	fake.saveNextInputMappingMutex.RLock()
	defer fake.saveNextInputMappingMutex.RUnlock()
	fake.pauseJobMutex.RLock()
	defer fake.pauseJobMutex.RUnlock()
	fake.unpauseJobMutex.RLock()
	defer fake.unpauseJobMutex.RUnlock()
	fake.getNextBuildInputsMutex.RLock()
	defer fake.getNextBuildInputsMutex.RUnlock()
	fake.deleteNextInputMappingMutex.RLock()
	defer fake.deleteNextInputMappingMutex.RUnlock()
	fake.getRunningBuildsBySerialGroupMutex.RLock()
	defer fake.getRunningBuildsBySerialGroupMutex.RUnlock()
	fake.getNextPendingBuildBySerialGroupMutex.RLock()
	defer fake.getNextPendingBuildBySerialGroupMutex.RUnlock()
	fake.getJobFinishedAndNextBuildMutex.RLock()
	defer fake.getJobFinishedAndNextBuildMutex.RUnlock()
	fake.getAllJobBuildsMutex.RLock()
	defer fake.getAllJobBuildsMutex.RUnlock()
	fake.createJobBuildMutex.RLock()
	defer fake.createJobBuildMutex.RUnlock()
	fake.setMaxInFlightReachedMutex.RLock()
	defer fake.setMaxInFlightReachedMutex.RUnlock()
	fake.updateFirstLoggedBuildIDMutex.RLock()
	defer fake.updateFirstLoggedBuildIDMutex.RUnlock()
	fake.updateBuildToScheduledMutex.RLock()
	defer fake.updateBuildToScheduledMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return fake.invocations
}

func (fake *FakePipelineDB) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.PipelineDB = new(FakePipelineDB)
